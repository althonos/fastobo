//! A PEG copy of the OBO format 1.4 syntax.
//!
//! # See also
//!
//! - [OBO Flat File Format 1.4 syntax](http://purl.obolibrary.org/obo/oboformat/spec.html)
//! - [IRI syntax (IETF RFC 3987)](https://tools.ietf.org/html/rfc3987#section-2.2)


// 2.1 BNF Notation

Boolean = { "true" | "false" }

AltIdTag                               = { "alt_id:" }
AutoGeneratedByTag                     = { "auto-generated-by:" }
BuiltinTag                             = { "builtin:" }
CommentTag                             = { "comment:" }
ConsiderTag                            = { "consider:" }
CreatedByTag                           = { "created_by:" }
CreationDateTag                        = { "creation_date:" }
DataVersionTag                         = { "data-version:" }
DateTag                                = { "date:" }
DisjointFromTag                        = { "disjoint_from:" }
DisjointOverTag                        = { "disjoint_over:" }
DefTag                                 = { "def:" }
DefaultNamespaceTag                    = { "default-namespace:" }
DomainTag                              = { "domain:" }
EquivalentToTag                        = { "equivalent_to:" }
EquivalentToChainTag                   = { "equivalent_to_chain:" }
ExpandAssertionToTag                   = { "expand_assertion_to:" }
ExpandExpressionToTag                  = { "expand_expression_to:" }
FormatVersionTag                       = { "format-version:" }
HoldsOverChainTag                      = { "holds_over_chain:" }
IdspaceTag                             = { "idspace:" }
ImportTag                              = { "import:" }
InstanceOfTag                          = { "instance_of:" }
IntersectionOfTag                      = { "intersection_of:" }
InverseOfTag                           = { "inverse_of:"}
IsATag                                 = { "is_a:" }
IsAnonymousTag                         = { "is_anonymous:"}
IsAntiSymmetricTag                     = { "is_anti_symmetric:" }
IsClassLevelTag                        = { "is_class_level:"}
IsCyclicTag                            = { "is_cyclic:" }
IsFunctionalTag                        = { "is_functional:" }
IsInverseFunctionalTag                 = { "is_inverse_functional:" }
IsMetadataTagTag                       = { "is_metadata_tag:" }
IsObsoleteTag                          = { "is_obsolete:" }
IsReflexiveTag                         = { "is_reflexive:" }
IsSymmetricTag                         = { "is_symmetric:" }
IsTransitiveTag                        = { "is_transitive:" }
NameTag                                = { "name:" }
NamespaceTag                           = { "namespace:" }
OntologyTag                            = { "ontology:" }
OwlAxiomsTag                           = { "owl-axioms:" }
PropertyValueTag                       = { "property_value:" }
RelationshipTag                        = { "relationship:" }
RangeTag                               = { "range:" }
RemarkTag                              = { "remark:" }
ReplacedByTag                          = { "replaced_by:" }
SavedByTag                             = { "saved-by:" }
SubsetTag                              = { "subset:" }
SubsetdefTag                           = { "subsetdef:" }
SynonymTypedefTag                      = { "synonymtypedef:" }
SynonymTag                             = { "synonym:" }
TransitiveOverTag                      = { "transitive_over:" }
TreatXrefsAsEquivalentTag              = { "treat-xrefs-as-equivalent:" }
TreatXrefsAsGenusDifferentiaTag        = { "treat-xrefs-as-reverse-genus-differentia:" }
TreatXrefsAsHasSubclassTag             = { "treat-xrefs-as-has-subclass:" }
TreatXrefsAsIsATag                     = { "treat-xrefs-as-is_a:" }
TreatXrefsAsReverseGenusDifferentiaTag = { "treat-xrefs-as-reverse-genus-differentia:" }
TreatXrefsAsRelationshipTag            = { "treat-xrefs-as-relationship: " }
UnionOfTag                             = { "union_of:" }
XrefTag                                = { "xref:" }

// 2.2 Characters

// 2.2.0 Basic Characters

AlphaChar = @{ ASCII_ALPHA }
Digit     = @{ ASCII_DIGIT }

// 2.2.1 Spacing Characters

WhitespaceChar = _{ " " | "\t" | "\u{0020}" }
NewlineChar    = _{ "\r" | "\n" | "\u{000c}"}
ws             = _{ WhitespaceChar+ }
nl             = _{ WhitespaceChar* ~ NewlineChar}

// 2.2.2 Special Characters

UniCodeChar = { ANY }
OboChar     = {
    // escaped character
    ("\\" ~ ANY)
    // unescaped character
  | (!"\\" ~ !"\n" ~ !"!" ~ ANY)
}
NonWsChar   = { !(WhitespaceChar) ~ !(NewlineChar) ~ OboChar }


// 2.3 Line Termination

EOL = { ws? ~ (QualifierList)? ~ ws? ~ HiddenComment? ~ nl  }

HiddenComment  = { "!" ~ ( !NewlineChar ~ UniCodeChar )* }

QualifierChar   = { !("=" | "," | "}" | "{" | "\"") ~ NonWsChar }
QualifierId    = @{ QualifierChar+ }
Qualifier      = { QualifierId ~ "=" ~ QuotedString }
QualifierList  = { "{" ~ Qualifier ~ ("," ~ ws ~ Qualifier)* ~ "}" }

// 2.4 Clause Values

QuotedString   = @{ "\"" ~ (!"\"" ~ ("!" | OboChar))* ~ "\"" }
UnquotedString = @{ OboChar+ }


// 2.5 Identifiers

// NB(@althonos): Since PEG are non-greedy, we sometimes have to make use of
//                positive predicates to turn non-greedy rules into greedy ones.
//
//                For instance, '00-01' parsed by the `IdLocal` rule can result
//                in the `CanonicalIdLocal` rule with `-01` as a remaining output,
//                but we actually want it as a `NonCanonicalIdLocal` without
//                remaining output.

ClassId       = { !"{" ~ Id }
RelationId    = { Id }
InstanceId    = { Id }
SynonymTypeId = { !"[" ~ Id }
NamespaceId   = { Id }
SubsetId      = { Id }

Id           = { UrlId | PrefixedId | UnprefixedId }
UrlId        = @{ ("http" | "https") ~ ":" ~ (NonWsChar)* }
UnprefixedId = @{ ( !":" ~ NonWsChar )+ }
PrefixedId   = {  IdPrefix ~ ":" ~ IdLocal }

IdPrefix             = { (CanonicalIdPrefix | NonCanonicalIdPrefix) }
CanonicalIdPrefix    = @{ AlphaChar ~ (AlphaChar | "_")* ~ &(":" | EOI) }
NonCanonicalIdPrefix = @{ (!":" ~ NonWsChar)* }

IdLocal             = { (CanonicalIdLocal | NonCanonicalIdLocal) }
CanonicalIdLocal    = @{ ASCII_DIGIT+ ~ &(EOI | WhitespaceChar | NewlineChar) }
NonCanonicalIdLocal = @{ NonWsChar* }


// 2.6 Xref Lists

Xref         = { Id ~ (ws ~ QuotedString)? }

XrefChar     = { !"," ~ !"]" ~ NonWsChar }
XrefId       = { XrefChar+ }
XrefListItem = { XrefId ~ (ws ~ QuotedString)? }
XrefList     = {"[" ~ (XrefListItem ~ ws?)? ~ ("," ~ ws ~ XrefListItem)* ~ ws? ~ "]"}

// 3 Obo Grammar

// 3.1 Obo Document Structure

OboDoc      = { HeaderFrame ~ (EntityFrame)* ~ nl* ~ EOI }
EntityFrame = { TermFrame | InstanceFrame | TypedefFrame }

EntitySingle = _{ nl* ~ EntityFrame ~ nl* ~ EOI }  // NB(@althonos): for iterative parsers.


// 3.2 Obo Headers

HeaderFrame = {
    (ws? ~ HeaderClause ~ nl*)*
}

NaiveDateTime = { NaiveDate ~ ws ~ NaiveTime }
NaiveDate     = { NaiveDay ~ ":" ~ NaiveMonth ~ ":" ~ NaiveYear }
NaiveTime     = { NaiveHour ~ ":" ~ NaiveMinute }
NaiveDay      = { ("0" ~ '1'..'9') | ('1' .. '2' ~ '0'..'9') | "30" | "31" }
NaiveMonth    = { ("0" ~ '1'..'9') | ("1" ~ '0'..'2') }
NaiveYear     = { Digit{4} }
NaiveHour     = { ('0'..'1' ~ '0' .. '9') | ("2" ~ '0' .. '3') }
NaiveMinute   = { ('0'..'5' ~ '0' .. '9') }

HeaderClause = {
    FormatVersionTag ~ ws ~ UnquotedString
  | DataVersionTag ~ ws ~ UnquotedString
  | DateTag ~ ws ~ NaiveDateTime
  | SavedByTag ~ ws ~ UnquotedString
  | AutoGeneratedByTag ~ ws ~ UnquotedString
  | ImportTag ~ ws ~ Import
  | SubsetdefTag ~ ws ~ SubsetId ~ ws ~ QuotedString
  | SynonymTypedefTag ~ ws ~ SynonymTypeId ~ ws ~ QuotedString ~ (ws ~ SynonymScope)?
  | DefaultNamespaceTag ~ ws ~ NamespaceId
  | IdspaceTag ~ ws ~ IdPrefix ~ ws ~ Iri ~ (ws ~ QuotedString)?
  | TreatXrefsAsEquivalentTag ~ ws ~ IdPrefix
  | TreatXrefsAsGenusDifferentiaTag ~ ws ~ IdPrefix ~ ws ~ RelationId ~ ws ~ ClassId
  | TreatXrefsAsReverseGenusDifferentiaTag ~ ws ~ IdPrefix ~ ws ~ RelationId ~ ws ~ ClassId
  | TreatXrefsAsRelationshipTag ~ ws ~ IdPrefix ~ ws ~ RelationId
  | TreatXrefsAsIsATag ~ ws ~ IdPrefix
  | TreatXrefsAsHasSubclassTag ~ ws ~ IdPrefix
  // FIXME(@althonos): allow EOL
  | PropertyValueTag ~ ws ~ PropertyValue
  | RemarkTag ~ ws ~ UnquotedString
  | OntologyTag ~ ws ~ UnquotedString
  | OwlAxiomsTag ~ ws ~ UnquotedString
  | Unreserved ~ ":" ~ ws ~ UnquotedString
}

Unreserved = {
    !FormatVersionTag ~
    !DataVersionTag ~
    !DateTag ~
    !SavedByTag ~
    !AutoGeneratedByTag ~
    !ImportTag ~
    !SubsetdefTag ~
    !SynonymTypedefTag ~
    !DefaultNamespaceTag ~
    !IdspaceTag ~
    !TreatXrefsAsEquivalentTag ~
    !TreatXrefsAsGenusDifferentiaTag ~
    !TreatXrefsAsReverseGenusDifferentiaTag ~
    !TreatXrefsAsRelationshipTag ~
    !TreatXrefsAsIsATag ~
    !TreatXrefsAsHasSubclassTag ~
    !PropertyValueTag ~
    !RemarkTag ~
    !OntologyTag ~
    !OwlAxiomsTag ~
    (!":" ~ OboChar)+
}


// 3.3 Term Frames

TermFrame = { nl*
    ~ "[Term]" ~ nl
    ~ ws? ~ "id:" ~ ws ~ ClassId ~ EOL
    ~ TermClauseLine*
}
TermClauseLine = {
    ws? ~ TermClause ~ EOL
}
TermClause = {
    IsAnonymousTag ~ ws ~ Boolean
  | NameTag ~ ws ~ UnquotedString
  | NamespaceTag ~ ws ~ NamespaceId
  | AltIdTag ~ ws ~ Id
  | DefTag ~ ws ~ QuotedString ~ ws ~ XrefList
  | CommentTag ~ ws ~ UnquotedString
  | SubsetTag ~ ws ~ SubsetId
  | SynonymTag ~ ws ~ Synonym
  | XrefTag ~ ws ~ Xref
  | BuiltinTag ~ ws ~ Boolean
  | PropertyValueTag ~ ws ~ PropertyValue
  | IsATag ~ ws ~ ClassId
  | IntersectionOfTag ~ ws ~ ((RelationId ~ ws ~ ClassId) | ClassId)
  | UnionOfTag ~ ws ~ ClassId
  | EquivalentToTag ~ ws ~ ClassId
  | DisjointFromTag ~ ws ~ ClassId
  | RelationshipTag ~ ws ~ RelationId ~ ws ~ ClassId
  | IsObsoleteTag ~ ws ~ Boolean
  | ReplacedByTag ~ ws ~ ClassId
  | ConsiderTag ~ ws ~ ClassId
  | CreatedByTag ~ ws ~ UnquotedString
  | CreationDateTag ~ ws ~ Iso8601DateTime
}


// 3.4 Typedef Frames

TypedefFrame = { nl*
    ~ "[Typedef]" ~ nl
    ~  ws? ~ "id:" ~ ws ~ ClassId ~ EOL
    ~ TypedefClauseLine*
}
TypedefClauseLine = {
    ws? ~ TypedefClause ~ EOL
}
TypedefClause = {
    IsAnonymousTag ~ ws ~ Boolean
  | NameTag ~ ws ~ UnquotedString
  | NamespaceTag ~ ws ~ NamespaceId
  | AltIdTag ~ ws ~ Id
  | DefTag ~ ws ~ QuotedString ~ ws ~ XrefList
  | CommentTag ~ ws ~ UnquotedString
  | SubsetTag ~ ws ~ SubsetId
  | SynonymTag ~ ws ~ Synonym
  | XrefTag ~ ws ~ Xref
  | PropertyValueTag ~ ws ~ PropertyValue
  | DomainTag ~ ws ~ ClassId
  | RangeTag ~ ws ~ ClassId
  | BuiltinTag ~ ws ~ Boolean
  | HoldsOverChainTag ~ ws ~ RelationId ~ ws ~ RelationId
  | IsAntiSymmetricTag ~ ws ~ Boolean
  | IsCyclicTag ~ ws ~ Boolean
  | IsReflexiveTag ~ ws ~ Boolean
  | IsSymmetricTag ~ ws ~ Boolean
  | IsTransitiveTag ~ ws ~ Boolean
  | IsFunctionalTag ~ ws ~ Boolean
  | IsInverseFunctionalTag ~ ws ~ Boolean
  | IsATag ~ ws ~ RelationId
  | IntersectionOfTag ~ ws ~ RelationId
  | UnionOfTag ~ ws ~ RelationId
  | EquivalentToTag ~ ws ~ RelationId
  | DisjointFromTag ~ ws ~ RelationId
  | InverseOfTag ~ ws ~ RelationId
  | TransitiveOverTag ~ ws ~ RelationId
  | EquivalentToChainTag ~ ws ~ RelationId ~ ws ~ RelationId
  | DisjointOverTag ~ ws ~ RelationId
  | RelationshipTag ~ ws ~ RelationId ~ ws ~ RelationId
  | IsObsoleteTag ~ ws ~ Boolean
  | ReplacedByTag ~ ws ~ RelationId
  | ConsiderTag ~ ws ~ Id
  | CreatedByTag ~ ws ~ UnquotedString
  | CreationDateTag ~ ws ~ Iso8601DateTime
  | ExpandAssertionToTag ~ ws ~ QuotedString ~ ws ~ XrefList
  | ExpandExpressionToTag ~ ws ~ QuotedString ~ ws ~ XrefList
  | IsMetadataTagTag ~ ws ~ Boolean
  | IsClassLevelTag ~ ws ~ Boolean
}


// 3.5 Instance Frames

InstanceFrame = { nl*
    ~ "[Instance]" ~ nl
    ~ ws? ~ "id:" ~ ws ~ InstanceId ~ EOL
    ~ InstanceClauseLine*
}
InstanceClauseLine = {
    ws? ~ InstanceClause ~ EOL
}
InstanceClause = {
    IsAnonymousTag ~ ws ~ Boolean
  | NameTag ~ ws ~ UnquotedString
  | NamespaceTag ~ ws ~ NamespaceId
  | AltIdTag ~ ws ~ Id
  | DefTag ~ ws ~ QuotedString ~ ws ~ XrefList
  | CommentTag ~ ws ~ UnquotedString
  | SubsetTag ~ ws ~ SubsetId
  | SynonymTag ~ ws ~ Synonym
  | XrefTag ~ ws ~ Xref
  | PropertyValueTag ~ ws ~ PropertyValue
  | InstanceOfTag ~ ws ~ ClassId
  | RelationshipTag ~ ws ~ RelationId ~ ws ~ InstanceId
  | CreatedByTag ~ ws ~ UnquotedString
  | CreationDateTag ~ ws ~ Iso8601DateTime
  | IsObsoleteTag ~ ws ~ Boolean
  | ReplacedByTag ~ ws ~ InstanceId
  | ConsiderTag ~ ws ~ Id
}


// 3.6 Synonym scope

SynonymScope = { "EXACT" | "BROAD" | "NARROW" | "RELATED" }
Synonym = { QuotedString ~ ws ~ SynonymScope ~ (ws ~ SynonymTypeId)? ~ ws ~ XrefList }

// 4.0 Misc

Import = { Iri | Id }

// WORKAROUND(@althonos): the 1.4 spec requires all property values to be
//                        quote-enclosed, but this is not done currently by the
//                        owlapi and owl2obo converters. As a workaround we can
//                        accept unquoted string without whitespaces as well as
//                        quoted strings for now.

PropertyValue = { RelationId ~ ws ~ (((QuotedString | PvValue) ~ ws ~ XsdDatatype) | Id) }

PvValue       = @{ NonWsChar+ }
XsdDatatype   = { "xsd:" ~ ASCII_ALPHANUMERIC+ }


// Annex I: Iri Grammar from [RFC3987]
//
// NB(@althonos): Since the `iri_string` crate is then used to parse the IRI,
//                there is no need for a proper tokenization of the IRI components.
//
//                Ideally, this would reside in another grammar file, but Pest
//                2.0 doesn't support sharing rules between files.

Iri = @{ IriScheme ~ ":" ~ IriHierPart ~ ("?" ~ IriQuery)? ~ ("#" ~ IriFragment)? }

IriHierPart = {
    ("//" ~ IriAuthority ~ IriPathAbempty )
  | IriPathAbsolute
  | IriPathRootless
  | IriPathEmpty
}

IriAuthority = { (IriUserInfo ~ "@")? ~ IriHost ~ (":" ~ IriPort)?}
IriUserInfo  = { (IriUnreserved | IriPctEncoded | IriSubDelims | ":")* }
IriHost      = { IriIpLiteral | IriIpv4Address | IriRegName }
IriRegName   = { (IriUnreserved | IriPctEncoded | IriSubDelims)* }

IriPath         = {IriPathAbempty | IriPathAbsolute | IriPathNoScheme | IriPathRootless | IriPathEmpty}
IriPathAbempty  = { ("/" ~ IriSegment)+ }
IriPathAbsolute = { "/" ~ (IriSegmentNz ~ ("/" ~ IriSegment)* )? }
IriPathNoScheme = { IriSegmentNzNc ~ ("/" ~ IriSegment)* }
IriPathRootless = { IriSegmentNz ~ ("/" ~ IriSegment)* }
IriPathEmpty    = { "0" ~ IriIpChar}

IriSegment     = { IriIpChar* }
IriSegmentNz   = { IriIpChar+ }
IriSegmentNzNc = { (IriUnreserved | IriPctEncoded | IriSubDelims | "@")+ }

IriQuery    = { (IriIpChar | IriPrivate | "/" | "?")* }
IriFragment = { (IriIpChar | "/" | "?")* }

IriScheme     = @{ ASCII_ALPHA ~ (ASCII_ALPHA | ASCII_DIGIT | "+" | "-" | ".")* }
IriPort       = @{ ASCII_DIGIT* }

IriPrivate    =  { '\u{E000}'..'\u{F8FF}' | '\u{F0000}'..'\u{FFFFD}' | '\u{100000}'..'\u{10FFFD}' }
IriPctEncoded =  { "%" ~ ASCII_HEX_DIGIT ~ ASCII_HEX_DIGIT }
IriUnreserved = @{ ASCII_ALPHA | ASCII_DIGIT | "-" | "." | "_" | "~" }
IriReserved   = @{ IriGenDelims | IriSubDelims }
IriGenDelims  = @{":" | "/" | "?" | "#" | "[" | "]" | "@"}
IriSubDelims  = @{"!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "="}
IriDecOctet   = {
    ASCII_DIGIT
  | (('1' .. '9') ~ ASCII_DIGIT)
  | ("1" ~ ASCII_DIGIT ~ ASCII_DIGIT)
  | ("2" ~ ('0' .. '4') ~ ASCII_DIGIT)
  | ("25" ~ ('0' .. '5'))
}

IriIpChar = { IriUnreserved | IriPctEncoded | IriSubDelims | ":" | "@" }
IriIpLiteral = { "[" ~ (IriIpv6Address ~ IriIpvFutureAddress)* ~ "]" }

IriIpv6H16  = { ASCII_HEX_DIGIT{1,4} }
IriIpv6Ls32 = { (IriIpv6H16 ~ ":" ~ IriIpv6H16) | IriIpv4Address }

IriIpv4Address      = { IriDecOctet ~ "." ~ IriDecOctet ~ "." ~ IriDecOctet ~ "." ~ IriDecOctet }
IriIpvFutureAddress = { "v" ~ ASCII_HEX_DIGIT+ ~ "." ~ (IriUnreserved | IriSubDelims | ":")+ }
IriIpv6Address      = {
    ( (IriIpv6H16 ~ ":"){6} ~ IriIpv6Ls32 )
  | ( "::" ~ (IriIpv6H16 ~ ":"){5} ~ IriIpv6Ls32 )
  | ( IriIpv6H16? ~ "::" ~ (IriIpv6H16 ~ ":"){4} ~ IriIpv6Ls32 )
  | ( ((IriIpv6H16 ~ ":"){1} ~ IriIpv6H16)? ~ "::" ~ (IriIpv6H16 ~ ":"){3} ~ IriIpv6Ls32)
  | ( ((IriIpv6H16 ~ ":"){2} ~ IriIpv6H16)? ~ "::" ~ (IriIpv6H16 ~ ":"){2} ~ IriIpv6Ls32)
  | ( ((IriIpv6H16 ~ ":"){3} ~ IriIpv6H16)? ~ "::" ~ IriIpv6H16 ~ ":" ~ IriIpv6Ls32)
  | ( ((IriIpv6H16 ~ ":"){4} ~ IriIpv6H16)? ~ "::" ~ IriIpv6Ls32)
  | ( ((IriIpv6H16 ~ ":"){5} ~ IriIpv6H16)? ~ "::" ~ IriIpv6H16)
  | ( ((IriIpv6H16 ~ ":"){6} ~ IriIpv6H16)? ~ "::")
}


// Annex II: ISO-8601 Grammar for DateTime w/ Timezone
Iso8601DateTime = {Iso8601Date ~ "T" ~ Iso8601Time ~ Iso8601TimeZone? }

Iso8601Date    = ${ Iso8601Year ~ Iso8601DateSep? ~ Iso8601Month ~ Iso8601DateSep? ~ Iso8601Day }
Iso8601DateSep = _{"-" | "–"}
Iso8601Year    = @{ ASCII_DIGIT{4} }
Iso8601Month   = @{ ASCII_DIGIT{1,2} }
Iso8601Day     = @{ ASCII_DIGIT{1,2} }

Iso8601Time    = ${ Iso8601Hour ~ Iso8601TimeSep? ~ Iso8601Minute ~ Iso8601TimeSep? ~ Iso8601Second }
Iso8601TimeSep = _{":"}
Iso8601Hour    = @{ (('0'..'1') ~ ('0'..'9')) | "2" ~ '0'..'4' }
Iso8601Minute  = @{ ('0'..'5') ~ ('0'..'9') }
Iso8601Second  = @{ (('0'..'5') ~ ('0'..'9')) | "60" }

Iso8601TimeZone = { "Z" | (("+" | "-") ~ Iso8601Hour ~ ":"? ~ Iso8601Minute) }
