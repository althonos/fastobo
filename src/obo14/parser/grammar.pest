//! A PEG copy of the OBO format 1.4 syntax.
//!
//! # See also
//!
//! - [OBO Flat File Format 1.4 syntax](http://purl.obolibrary.org/obo/oboformat/spec.html)
//! - [IRI syntax (IETF RFC 3987)](https://tools.ietf.org/html/rfc3987#section-2.2)


// 2.1 BNF Notation

Boolean = { "true" | "false" }

AltIdTag                               = { "alt_id:" }
AutoGeneratedByTag                     = { "auto-generated-by:" }
BuiltinTag                             = { "builtin:" }
CommentTag                             = { "comment:" }
ConsiderTag                            = { "consider:" }
CreatedByTag                           = { "created_by:" }
CreationDateTag                        = { "creation_date:" }
DataVersionTag                         = { "data-version:" }
DateTag                                = { "date:" }
DisjointFromTag                        = { "disjoint_from:" }
DefTag                                 = { "def:" }
DefaultNamespaceTag                    = { "default-namespace:" }
EquivalentToTag                        = { "equivalent_to:" }
FormatVersionTag                       = { "format-version:" }
IdspaceTag                             = { "idspace:" }
IntersectionOfTag                      = { "intersection_of:" }
IsATag                                 = { "is_a:" }
IsAnonymousTag                         = { "is_anonymous:"}
IsObsoleteTag                          = { "is_obsolete:" }
ImportTag                              = { "import:" }
NameTag                                = { "name:" }
NamespaceTag                           = { "namespace:" }
OntologyTag                            = { "ontology:" }
OwlAxiomsTag                           = { "owl-axioms:" }
PropertyValueTag                       = { "property_value:" }
RelationshipTag                        = { "relationship:" }
RemarkTag                              = { "remark:" }
ReplacedByTag                          = { "replaced_by:" }
SavedByTag                             = { "saved-by:" }
SubsetTag                              = { "subset:" }
SubsetdefTag                           = { "subsetdef:" }
SynonymTypedefTag                      = { "synonymtypedef:" }
SynonymTag                             = { "synonym:" }
TreatXrefsAsEquivalentTag              = { "treat-xrefs-as-equivalent:" }
TreatXrefsAsGenusDifferentiaTag        = { "treat-xrefs-as-reverse-genus-differentia:" }
TreatXrefsAsHasSubclassTag             = { "treat-xrefs-as-has-subclass:" }
TreatXrefsAsIsATag                     = { "treat-xrefs-as-is_a:" }
TreatXrefsAsReverseGenusDifferentiaTag = { "treat-xrefs-as-reverse-genus-differentia:" }
TreatXrefsAsRelationshipTag            = { "treat-xrefs-as-relationship: " }
UnionOfTag                             = { "union_of:" }
XrefTag                                = { "xref:" }

// 2.2 Characters

// 2.2.0 Basic Characters

AlphaChar = @{ ASCII_ALPHA }
Digit     = @{ ASCII_DIGIT }

// 2.2.1 Spacing Characters

WhitespaceChar = _{ " " | "\t" | "\u{0020}" }
NewlineChar    = _{ "\r" | "\n" | "\u{000c}"}
ws             = _{ WhitespaceChar+ }
nl             = _{ WhitespaceChar* ~ NewlineChar}

// 2.2.2 Special Characters

UniCodeChar = { ANY }
OboChar     = {
    // escaped character
    ("\\" ~ ("\\" | " " | "f" | "n" | "r" | "t" | "\""))
    // unescaped character
  | (!("\\") ~ !("\n") ~ ANY)
}
NonWsChar   = { !(WhitespaceChar) ~ !(NewlineChar) ~ OboChar }


// 2.3 Line Termination

EOL = { WhitespaceChar* ~ (QualifierBlock ~ ws)? ~ HiddenComment? ~ nl  }

HiddenComment  = { "!" ~ ( !NewlineChar ~ UniCodeChar )* }

Qualifier      = { !"}" ~ Id ~ "=" ~ QuotedString }
QualifierList  = { Qualifier ~ ("," ~ ws ~ Qualifier)* }
QualifierBlock = { "{" ~ QualifierList ~ "}" }


// 2.4 Clause Values

QuotedString   = @{ "\"" ~ ( !"\"" ~ OboChar )* ~ "\"" }
UnquotedString = @{ OboChar+ }


// 2.5 Identifiers

// NB(@althonos): Since PEG are non-greedy, we sometimes have to make use of
//                positive predicates to turn non-greedy rules into greedy ones.
//
//                For instance, '00-01' parsed by the `IdLocal` rule can result
//                in the `CanonicalIdLocal` rule with `-01` as a remaining output,
//                but we actually want it as a `NonCanonicalIdLocal` without
//                remaining output.

ClassId       = { Id }
RelationId    = { Id }
InstanceId    = { Id }
SynonymTypeId = { !"[" ~ Id }   // FIXME(@althonos): Hackish.
NamespaceId   = { Id }
PersonId      = { Id }
SubsetId      = { Id }

Id           = { UrlId | PrefixedId | UnprefixedId }
UrlId        = @{ ("http" | "https") ~ ":" ~ (NonWsChar)* }
UnprefixedId = @{ ( !":" ~ NonWsChar )+ }
PrefixedId   = {  IdPrefix ~ ":" ~ IdLocal }

IdPrefix             = { (CanonicalIdPrefix | NonCanonicalIdPrefix) }
CanonicalIdPrefix    = @{ AlphaChar ~ (AlphaChar | "_")* ~ &(":") }
NonCanonicalIdPrefix = @{ (!":" ~ NonWsChar)* }

IdLocal             = { (CanonicalIdLocal | NonCanonicalIdLocal) }
CanonicalIdLocal    = @{ ASCII_DIGIT+ ~ &(EOI | WhitespaceChar | NewlineChar) }
NonCanonicalIdLocal = @{ NonWsChar* }


// 2.6 Xref Lists

Xref         = { Id ~ (ws ~ QuotedString)? }

// FIXME(@althonos): doing like QualifierBlock might be a better option.
XrefChar     = { !"," ~ !"]" ~ !"[" ~ NonWsChar }
XrefId       = { XrefChar+ }
XrefListItem = { XrefId ~ (ws ~ QuotedString)? }
XrefList     = {"[" ~ (XrefListItem ~ ws?)? ~ ("," ~ ws ~ XrefListItem)* ~ ws? ~ "]"}

// 3 Obo Grammar

// 3.1 Obo Document Structure

OboDoc      = { HeaderFrame ~ (EntityFrame)* ~ nl* ~ EOI }
EntityFrame = { TermFrame | InstanceFrame | TypedefFrame }


// 3.2 Obo Headers

HeaderFrame = {
    (ws? ~ HeaderClause ~ nl*)*
}

NaiveDateTime = { NaiveDate ~ ws ~ NaiveTime }
NaiveDate     = { NaiveDay ~ ":" ~ NaiveMonth ~ ":" ~ NaiveYear }
NaiveTime     = { NaiveHour ~ ":" ~ NaiveMinute }
NaiveDay      = { ("0" ~ '1'..'9') | ('1' .. '2' ~ '0'..'9') | "30" | "31" }
NaiveMonth    = { ("0" ~ '1'..'9') | ("1" ~ '0'..'2') }
NaiveYear     = { Digit{4} }
NaiveHour     = { ('0'..'1' ~ '0' .. '9') | ("2" ~ '0' .. '3') }
NaiveMinute   = { ('0'..'5' ~ '0' .. '9') }

HeaderClause = {
    FormatVersionTag ~ ws ~ UnquotedString
|   DataVersionTag ~ ws ~ UnquotedString
|   DateTag ~ ws ~ NaiveDateTime
|   SavedByTag ~ ws ~ UnquotedString
|   AutoGeneratedByTag ~ ws ~ UnquotedString
|   ImportTag ~ ws ~ Import
|   SubsetdefTag ~ ws ~ SubsetId ~ ws ~ QuotedString
|   SynonymTypedefTag ~ ws ~ SynonymTypeId ~ ws ~ QuotedString ~ (ws ~ SynonymScope)?
|   DefaultNamespaceTag ~ ws ~ NamespaceId
|   IdspaceTag ~ ws ~ IdPrefix ~ ws ~ Iri ~ (ws ~ QuotedString)?
|   TreatXrefsAsEquivalentTag ~ ws ~ IdPrefix
|   TreatXrefsAsGenusDifferentiaTag ~ ws ~ IdPrefix ~ ws ~ RelationId ~ ws ~ ClassId
|   TreatXrefsAsReverseGenusDifferentiaTag ~ ws ~ IdPrefix ~ ws ~ RelationId ~ ws ~ ClassId
|   TreatXrefsAsRelationshipTag ~ ws ~ IdPrefix ~ ws ~ RelationId
|   TreatXrefsAsIsATag ~ ws ~ IdPrefix
|   TreatXrefsAsHasSubclassTag ~ ws ~ IdPrefix
// FIXME(@althonos): allow EOL
|   PropertyValueTag ~ ws ~ PropertyValue
|   RemarkTag ~ ws ~ UnquotedString
|   OntologyTag ~ ws ~ UnquotedString
|   OwlAxiomsTag ~ ws ~ UnquotedString
|   Unreserved ~ ":" ~ ws ~ UnquotedString
}

Unreserved = { (!":" ~ OboChar)+ }


// 3.3 Term Frames

TermFrame = { nl*
    ~ "[Term]" ~ nl
    ~ ws? ~ "id:" ~ ws ~ ClassId ~ EOL
    ~ TermClauseLine*
}

TermClauseLine = { ws? ~ TermClause ~ EOL }

TermClause = {
    IsAnonymousTag ~ ws ~ Boolean
  | NameTag ~ ws ~ UnquotedString
  | NamespaceTag ~ ws ~ NamespaceId
  | AltIdTag ~ ws ~ Id
  | DefTag ~ ws ~ QuotedString ~ ws ~ XrefList
  | CommentTag ~ ws ~ UnquotedString
  | SubsetTag ~ ws ~ SubsetId
  | SynonymTag ~ ws ~ QuotedString ~ ws ~ SynonymScope ~ (ws ~ SynonymTypeId)? ~ ws ~ XrefList
  | XrefTag ~ ws ~ Xref
  | BuiltinTag ~ ws ~ Boolean
  | PropertyValueTag ~ ws ~ PropertyValue
  | IsATag ~ ws ~ ClassId
  | IntersectionOfTag ~ ws ~ ClassId
  | IntersectionOfTag ~ ws ~ RelationId ~ ws ~ ClassId
  | UnionOfTag ~ ws ~ ClassId
  | EquivalentToTag ~ ws ~ ClassId
  | DisjointFromTag ~ ws ~ ClassId
  | RelationshipTag ~ ws ~ RelationId ~ ws ~ ClassId
  | IsObsoleteTag ~ ws ~ Boolean
  | ReplacedByTag ~ ws ~ ClassId
  | ConsiderTag ~ ws ~ ClassId
  | CreatedByTag ~ ws ~ PersonId
  | CreationDateTag ~ ws ~ Iso8601DateTime
}


// 3.4 Typedef Frames

TypedefFrame = { nl*
    ~ "[Typedef]" ~ nl
    ~  ws? ~ "id:" ~ ws ~ ClassId ~ EOL
    ~ (ws? ~ TypedefFrameClause ~ EOL)*
}

// TODO
TypedefFrameClause = {
  IsAnonymousTag ~ ws ~ Boolean
}


// 3.5 Instance Frames

InstanceFrame = { nl*
    ~ "[Instance]" ~ nl
    ~ "id:" ~ ws ~ ClassId ~ EOL
    ~ (InstanceFrameClause ~ EOL)*
}

// TODO
InstanceFrameClause = {
    "is_anonymous:" ~ ws ~ Boolean
}



// 3.6 Synonym scope

SynonymScope = { "EXACT" | "BROAD" | "NARROW" | "RELATED" }


// 4.0 Misc

Import = { Iri | Id }

PropertyValue = { RelationId ~ ws ~ ((QuotedString ~ ws ~ XsdDatatype) | Id) }
XsdDatatype   = { "xsd:" ~ ASCII_ALPHANUMERIC+ }


// Annex I: Iri Grammar from [RFC3987]
//
// NB(@althonos): Since the `iri_string` crate is then used to parse the IRI,
//                there is no need for a proper tokenization of the IRI components.
//
//                Ideally, this would reside in another grammar file, but Pest
//                2.0 doesn't support sharing rules between files.

Iri = @{ IriScheme ~ ":" ~ IriHierPart ~ ("?" ~ IriQuery)? ~ ("#" ~ IriFragment)? }

IriHierPart = {
    ("//" ~ IriAuthority ~ IriPathAbempty )
  | IriPathAbsolute
  | IriPathRootless
  | IriPathEmpty
}

IriAuthority = { (IriUserInfo ~ "@")? ~ IriHost ~ (":" ~ IriPort)?}
IriUserInfo  = { (IriUnreserved | IriPctEncoded | IriSubDelims | ":")* }
IriHost      = { IriIpLiteral | IriIpv4Address | IriRegName }
IriRegName   = { (IriUnreserved | IriPctEncoded | IriSubDelims)* }

IriPath         = {IriPathAbempty | IriPathAbsolute | IriPathNoScheme | IriPathRootless | IriPathEmpty}
IriPathAbempty  = { ("/" ~ IriSegment)+ }
IriPathAbsolute = { "/" ~ (IriSegmentNz ~ ("/" ~ IriSegment)* )? }
IriPathNoScheme = { IriSegmentNzNc ~ ("/" ~ IriSegment)* }
IriPathRootless = { IriSegmentNz ~ ("/" ~ IriSegment)* }
IriPathEmpty    = { "0" ~ IriIpChar}

IriSegment     = { IriIpChar* }
IriSegmentNz   = { IriIpChar+ }
IriSegmentNzNc = { (IriUnreserved | IriPctEncoded | IriSubDelims | "@")+ }

IriQuery    = { (IriIpChar | IriPrivate | "/" | "?")* }
IriFragment = { (IriIpChar | "/" | "?")* }

IriScheme     = @{ ASCII_ALPHA ~ (ASCII_ALPHA | ASCII_DIGIT | "+" | "-" | ".")* }
IriPort       = @{ ASCII_DIGIT* }

IriPrivate    =  { '\u{E000}'..'\u{F8FF}' | '\u{F0000}'..'\u{FFFFD}' | '\u{100000}'..'\u{10FFFD}' }
IriPctEncoded =  { "%" ~ ASCII_HEX_DIGIT ~ ASCII_HEX_DIGIT }
IriUnreserved = @{ ASCII_ALPHA | ASCII_DIGIT | "-" | "." | "_" | "~" }
IriReserved   = @{ IriGenDelims | IriSubDelims }
IriGenDelims  = @{":" | "/" | "?" | "#" | "[" | "]" | "@"}
IriSubDelims  = @{"!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "="}
IriDecOctet   = {
    ASCII_DIGIT
  | (('1' .. '9') ~ ASCII_DIGIT)
  | ("1" ~ ASCII_DIGIT ~ ASCII_DIGIT)
  | ("2" ~ ('0' .. '4') ~ ASCII_DIGIT)
  | ("25" ~ ('0' .. '5'))
}

IriIpChar = { IriUnreserved | IriPctEncoded | IriSubDelims | ":" | "@" }
IriIpLiteral = { "[" ~ (IriIpv6Address ~ IriIpvFutureAddress)* ~ "]" }

IriIpv6H16  = { ASCII_HEX_DIGIT{1,4} }
IriIpv6Ls32 = { (IriIpv6H16 ~ ":" ~ IriIpv6H16) | IriIpv4Address }

IriIpv4Address      = { IriDecOctet ~ "." ~ IriDecOctet ~ "." ~ IriDecOctet ~ "." ~ IriDecOctet }
IriIpvFutureAddress = { "v" ~ ASCII_HEX_DIGIT+ ~ "." ~ (IriUnreserved | IriSubDelims | ":")+ }
IriIpv6Address      = {
    ( (IriIpv6H16 ~ ":"){6} ~ IriIpv6Ls32 )
  | ( "::" ~ (IriIpv6H16 ~ ":"){5} ~ IriIpv6Ls32 )
  | ( IriIpv6H16? ~ "::" ~ (IriIpv6H16 ~ ":"){4} ~ IriIpv6Ls32 )
  | ( ((IriIpv6H16 ~ ":"){1} ~ IriIpv6H16)? ~ "::" ~ (IriIpv6H16 ~ ":"){3} ~ IriIpv6Ls32)
  | ( ((IriIpv6H16 ~ ":"){2} ~ IriIpv6H16)? ~ "::" ~ (IriIpv6H16 ~ ":"){2} ~ IriIpv6Ls32)
  | ( ((IriIpv6H16 ~ ":"){3} ~ IriIpv6H16)? ~ "::" ~ IriIpv6H16 ~ ":" ~ IriIpv6Ls32)
  | ( ((IriIpv6H16 ~ ":"){4} ~ IriIpv6H16)? ~ "::" ~ IriIpv6Ls32)
  | ( ((IriIpv6H16 ~ ":"){5} ~ IriIpv6H16)? ~ "::" ~ IriIpv6H16)
  | ( ((IriIpv6H16 ~ ":"){6} ~ IriIpv6H16)? ~ "::")
}


// Annex II: ISO-8601 Grammar for DateTime w/ Timezone
Iso8601DateTime = {Iso8601Date ~ "T" ~ Iso8601Time ~ Iso8601TimeZone }

Iso8601Date  = {
    Iso8601Year ~ Iso8601Month ~ Iso8601Day
  | Iso8601Year ~ "-" ~ Iso8601Month ~ "-" ~ Iso8601Day
}
Iso8601Year  = { ASCII_DIGIT{4} }
Iso8601Month = { "0" ~ '1'..'9' | "1" ~ '0'..'2' }
Iso8601Day   = { "0" ~ '1'..'9' | '1'..'2' ~ '0'..'9' | "30" | "31" }

Iso8601Time   = {
    Iso8601Hour ~ Iso8601Minute ~ Iso8601Second
  | Iso8601Hour ~ ":" ~ Iso8601Minute ~ ":" ~ Iso8601Second
}
Iso8601Hour   = { '0'..'1' ~ '0'..'9' | "2" ~ '0'..'3' }
Iso8601Minute = { '0'..'5' ~ '0'..'9' }
Iso8601Second = { '0'..'5' ~ '0'..'9' }

Iso8601TimeZone = { "Z" | ("+" | "-") ~ Iso8601Hour ~ ":"? ~ Iso8601Minute  }
