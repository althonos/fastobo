use std::fmt::Display;
use std::fmt::Formatter;
use std::fmt::Write;
use std::str::FromStr;

use chrono::naive::NaiveDateTime;
use chrono::Datelike;
use chrono::Timelike;

use crate::errors;

use super::super::ClassId;
use super::super::Id;
use super::super::IdPrefix;
use super::super::OboNamespace;
use super::super::PropertyValue;
use super::super::Qualifier;
use super::super::RelationId;
use super::super::SynonymScope;

/// A header clause, e.g. `format-version: 1.4`.
#[derive(Debug, PartialEq)]
pub enum HeaderClause {
    /// The OBO specification version this file uses.
    FormatVersion(String),
    /// The version of the current ontology.
    DataVersion(String),
    /// The ID space of this ontology.
    Ontology(IdPrefix),
    /// The date the ontology was created.
    Date(NaiveDateTime),
    /// The username of the person to last save this file.
    SavedBy(String),
    /// The program that generated the file.
    AutoGeneratedBy(String),
    /// A description of a term subset.
    Subsetdef(Id, String),
    /// A URL or ontology ID referencing another OBO document.
    Import(String),
    /// A description of a user-defined synonym type.
    SynonymTypedef(Id, String, Option<SynonymScope>),
    /// A mapping between a *local* ID space and a *global* ID space.
    IdSpace(IdPrefix, String, Option<String>),
    /// The default ID space for relationship missing one.
    DefaultRelationshipIdPrefix(IdPrefix),
    /// Maps a Term or Typedef ID to another Term or Typedef ID.
    IdMapping(Id, Id),
    /// General comments for this file.
    Remark(String),
    /// Treat all *xrefs* coming from a particular ID-Space as being statements
    /// of exact equivalence.
    TreatXrefsAsEquivalent(IdPrefix),
    /// Treats all xrefs coming from a particular ID-Space as being
    /// genus-differentia definitions (cross products, logical definitions,
    /// intersection definitions).
    TreatXrefsAsGenusDifferentia(IdPrefix, RelationId, ClassId),
    TreatXrefsAsReverseGenusDifferentia(IdPrefix, RelationId, ClassId),
    TreatXrefsAsRelationship(IdPrefix, RelationId),
    TreatXrefsAsIsA(IdPrefix),
    TreatXrefsAsHasSubclass(IdPrefix),
    /// A property value annotation.
    PropertyValue(PropertyValue, Option<Vec<Qualifier>>, Option<String>),
    /// Relax the assumption that no entities have the same `name` tag
    /// within the given namespace.
    RelaxUniqueLabelAssumptionForNamespace(OboNamespace),
    /// A unreserved token, for backward and forward compatibility.
    Unreserved(String, String),
}

impl Display for HeaderClause {
    fn fmt(&self, f: &mut Formatter) -> ::std::fmt::Result {
        use self::HeaderClause::*;
        match self {
            FormatVersion(s) => f
                .write_str("format-version: ")
                .and(write_escaped!(f, s, '\n' => "\\n")),
            DataVersion(s) => f
                .write_str("data-version: ")
                .and(write_escaped!(f, s, '\n' => "\\n")),
            Date(dt) => write!(
                f,
                "date: {:02}:{:02}:{:04} {:02}:{:02}",
                dt.day(),
                dt.month(),
                dt.year(),
                dt.hour(),
                dt.minute()
            ),
            AutoGeneratedBy(s) => f
                .write_str("auto-generated-by: ")
                .and(write_escaped!(f, s, '\n' => "\\n")),
            Ontology(s) => f
                .write_str("ontology: ")
                .and(write_escaped!(f, s, '\n' => "\\n")),
            SavedBy(s) => f
                .write_str("saved-by: ")
                .and(write_escaped!(f, s, '\n' => "\\n")),
            Import(s) => f
                .write_str("import: ")
                .and(write_escaped!(f, s, '\n' => "\\n")),
            Subsetdef(id, desc) => write!(f, "subsetdef: {} \"", id)
                .and(write_escaped!(f, desc, '\n' => "\\n", '"' => "\\\""))
                .and(f.write_char('"')),
            SynonymTypedef(id, desc, scope) => {
                let r = write!(f, "synonymtypedef: {} \"", id)
                    .and(write_escaped!(f, desc, '\n' => "\\n", '"' => "\\\""))
                    .and(f.write_char('"'));
                match scope {
                    Some(s) => r.and(write!(f, " {}", s)),
                    None => r,
                }
            }
            IdSpace(local, global, desc) => {
                let r = f
                    .write_str("idspace: ")
                    .and(write_escaped!(f, local, '\n' => "\\n", ':' => "\\:"))
                    .and(f.write_char(' '))
                    .and(write_escaped!(f, global, '\n' => "\\n"));
                match desc {
                    Some(d) => r
                        .and(f.write_str(" \""))
                        .and(write_escaped!(f, d, '\n' => "\\n", '"' => "\\\""))
                        .and(f.write_char('"')),
                    None => r,
                }
            }
            DefaultRelationshipIdPrefix(prefix) => f
                .write_str("default-relationship-id-prefix: ")
                .and(write_escaped!(f, prefix, '\n' => "\\n", ':' => "\\:")),
            IdMapping(local, global) => f
                .write_str("id-mapping: ")
                .and(local.fmt(f))
                .and(f.write_char(' '))
                .and(global.fmt(f)),
            Remark(s) => f
                .write_str("remark: ")
                .and(write_escaped!(f, s, '\n' => "\\n")),
            TreatXrefsAsEquivalent(prefix) => f
                .write_str("treat-xrefs-as-equivalent: ")
                .and(write_escaped!(f, prefix, '\n' => "\\n", ':' => "\\:")),
            TreatXrefsAsGenusDifferentia(prefix, rel, class) => f
                .write_str("treat-xrefs-as-genus-differentia: ")
                .and(write_escaped!(f, prefix, '\n' => "\\n", ':' => "\\:"))
                .and(write!(f, " {} {}", rel, class)),
            TreatXrefsAsReverseGenusDifferentia(prefix, rel, class) => f
                .write_str("treat-xrefs-as-reverse-genus-differentia: ")
                .and(write_escaped!(f, prefix, '\n' => "\\n", ':' => "\\:"))
                .and(write!(f, " {} {}", rel, class)),
            TreatXrefsAsRelationship(prefix, rel) => f
                .write_str("treat-xrefs-as-relationship: ")
                .and(write_escaped!(f, prefix, '\n' => "\\n", ':' => "\\:"))
                .and(write!(f, " {}", rel)),
            TreatXrefsAsIsA(prefix) => f
                .write_str("treat-xrefs-as-is_a: ")
                .and(write_escaped!(f, prefix, '\n' => "\\n", ':' => "\\:")),
            TreatXrefsAsHasSubclass(prefix) => f
                .write_str("treat-xrefs-as-has_subclass: ")
                .and(write_escaped!(f, prefix, '\n' => "\\n", ':' => "\\:")),
            PropertyValue(pv, qualifiers, comment) => write!(f, "property_value: {}", pv)
                .and(match qualifiers {
                    None => Ok(()),
                    Some(ref quals) => {
                        f.write_str(" {")?;
                        let mut it = quals.iter().peekable();
                        while let Some(q) = it.next() {
                            q.fmt(f)?;
                            if it.peek().is_some() {
                                println!("{:?}", it.peek());
                                f.write_str(", ")?;
                            }
                        }
                        f.write_char('}')
                    }
                })
                .and(match comment {
                    None => Ok(()),
                    Some(c) => write!(f, " ! {}", c),
                }),
            RelaxUniqueLabelAssumptionForNamespace(ns) => f
                .write_str("relax-unique-label-assumption-for-namespace: ")
                .and(write_escaped!(f, ns, ':' => "\\:", '\n' => "\\:")),
            Unreserved(key, value) => write_escaped!(f, key, '\n' => "\\n", ':' => "\\:")
                .and(f.write_str(": "))
                .and(write_escaped!(f, value, '\n' => "\\n")),
        }
    }
}

#[cfg(test)]
mod tests {
    use chrono::naive::NaiveDate;

    use super::*;

    mod display {
        use super::*;

        #[test]
        fn ontology() {
            let o = HeaderClause::Ontology("go".to_string());
            assert_eq!(o.to_string(), "ontology: go");
        }

        #[test]
        fn date() {
            let dt = NaiveDate::from_ymd(2018, 9, 14).and_hms(23, 2, 0);
            let date = HeaderClause::Date(dt);
            assert_eq!(date.to_string(), "date: 14:09:2018 23:02");
        }

        #[test]
        fn subsetdef() {
            let s = HeaderClause::Subsetdef(
                self::Id::Unprefixed("GO_SLIM".to_string()),
                "GO Slim".to_string(),
            );
            assert_eq!(s.to_string(), "subsetdef: GO_SLIM \"GO Slim\"")
        }

        #[test]
        fn import() {
            let i = HeaderClause::Import("http://purl.obolibrary.org/obo/go.owl".to_string());
            assert_eq!(
                i.to_string(),
                "import: http://purl.obolibrary.org/obo/go.owl"
            );
        }

        #[test]
        fn synonym_typedef() {
            let st = HeaderClause::SynonymTypedef(
                self::Id::Unprefixed("UK_SPELLING".to_string()),
                "British spelling".to_string(),
                Some(self::SynonymScope::Exact),
            );
            assert_eq!(
                st.to_string(),
                "synonymtypedef: UK_SPELLING \"British spelling\" EXACT"
            );
        }

        #[test]
        fn id_space() {
            let is = HeaderClause::IdSpace(
                "GO".to_string(),
                "urn:lsid:bioontology.org:GO:".to_string(),
                Some("gene ontology terms".to_string()),
            );
            assert_eq!(
                is.to_string(),
                "idspace: GO urn:lsid:bioontology.org:GO: \"gene ontology terms\""
            );
        }

        #[test]
        fn format_version() {
            let v = HeaderClause::FormatVersion("1.2".to_string());
            assert_eq!(v.to_string(), "format-version: 1.2");
        }

        #[test]
        fn default_relationship_id_prefix() {
            let d = HeaderClause::DefaultRelationshipIdPrefix("OBO_REL".to_string());
            assert_eq!(d.to_string(), "default-relationship-id-prefix: OBO_REL");
        }

        #[test]
        fn id_mapping() {
            let im = HeaderClause::IdMapping(
                self::Id::Unprefixed("part_of".to_string()),
                self::Id::Prefixed("OBO_REL".to_string(), "part_of".to_string()),
            );
            assert_eq!(im.to_string(), "id-mapping: part_of OBO_REL:part_of");
        }

        #[test]
        fn treat_xrefs_as_equivalent() {
            let t = HeaderClause::TreatXrefsAsEquivalent("CL".to_string());
            assert_eq!(t.to_string(), "treat-xrefs-as-equivalent: CL");
        }

        #[test]
        fn treat_xrefs_as_genus_differentia() {
            let t = HeaderClause::TreatXrefsAsGenusDifferentia(
                "CL".to_string(),
                self::Id::Unprefixed("part_of".to_string()).into(),
                self::Id::Prefixed("NCBITaxon".to_string(), "7955".to_string()).into(),
            );
            assert_eq!(
                t.to_string(),
                "treat-xrefs-as-genus-differentia: CL part_of NCBITaxon:7955"
            );
        }

        #[test]
        fn treat_xrefs_as_relationship() {
            let t = HeaderClause::TreatXrefsAsRelationship(
                "MA".to_string(),
                self::Id::Unprefixed("homologuous_to".to_string()).into(),
            );
            assert_eq!(
                t.to_string(),
                "treat-xrefs-as-relationship: MA homologuous_to"
            );
        }

        #[test]
        fn treat_xrefs_as_is_a() {
            let t = HeaderClause::TreatXrefsAsIsA("CL".to_string());
            assert_eq!(t.to_string(), "treat-xrefs-as-is_a: CL");
        }

        #[test]
        fn property_value() {
            let clause = HeaderClause::PropertyValue(
                PropertyValue::Identified(
                    Id::Unprefixed("married_to".to_string()).into(),
                    Id::Unprefixed("heather".to_string()),
                ),
                None,
                None,
            );
            assert_eq!(clause.to_string(), "property_value: married_to heather");

            let clause = HeaderClause::PropertyValue(
                PropertyValue::Identified(
                    Id::Unprefixed("married_to".to_string()).into(),
                    Id::Unprefixed("heather".to_string()),
                ),
                Some(vec![
                    Qualifier {
                        key: Id::Unprefixed("k1".to_string()),
                        value: "v1".to_string(),
                    },
                    Qualifier {
                        key: Id::Unprefixed("k2".to_string()),
                        value: "v2".to_string(),
                    },
                ]),
                None,
            );
            assert_eq!(
                clause.to_string(),
                "property_value: married_to heather {k1=\"v1\", k2=\"v2\"}"
            );

            let clause = HeaderClause::PropertyValue(
                PropertyValue::Identified(
                    Id::Unprefixed("married_to".to_string()).into(),
                    Id::Unprefixed("heather".to_string()),
                ),
                Some(vec![]),
                Some("comment".to_string()),
            );
            assert_eq!(
                clause.to_string(),
                "property_value: married_to heather {} ! comment"
            );

            let clause = HeaderClause::PropertyValue(
                PropertyValue::Typed(
                    Id::Unprefixed("shoe_size".to_string()).into(),
                    "8".to_string(),
                    "xsd:positiveInteger".to_string(),
                ),
                None,
                None,
            );
            assert_eq!(
                clause.to_string(),
                "property_value: shoe_size \"8\" xsd:positiveInteger"
            );
        }
    }
}
