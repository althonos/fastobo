//! Per-clause parsers.

use std::str::FromStr;

use chrono::NaiveDate;

use super::super::id::id;
use super::super::scope::synonym_scope;
use super::super::spacing::is_newline;
use super::super::spacing::is_whitespace;
use super::super::spacing::nl;
use super::super::spacing::ws;
use super::super::values::quoted_unescape;
use super::super::values::unquoted_unescape;

use super::ast;
use super::ast::HeaderClause;
use super::ast::HeaderClause::*;

// --- Deriving macro ----------------------------------------------------------

// --- Derived implementations -------------------------------------------------

tvp_h!(format_version, "format-version:", FormatVersion);
tvp_h!(data_version, "data-version:", DataVersion);
tvp_h!(saved_by, "saved-by:", SavedBy);
tvp_h!(auto_generated_by, "auto-generated-by:", AutoGeneratedBy);
tvp_h!(remark, "remark:", Remark);
tvp_h!(ontology, "ontology:", Ontology);

// --- Dedicated clauses -------------------------------------------------------

named!(date<&str, HeaderClause>,
    map_opt!(
        do_parse!(
                    tag!("date:")                     >>
                    opt!(ws)                          >>
            dd:     map_res!(take!(2), u32::from_str)  >>
                    tag!(":")                         >>
            mm:     map_res!(take!(2), u32::from_str)  >>
                    tag!(":")                         >>
            yyyy:   map_res!(take!(4), i32::from_str) >>
                    ws                                >>
            h:      map_res!(take!(2), u32::from_str)  >>
                    tag!(":")                         >>
            m:      map_res!(take!(2), u32::from_str)  >>
                    (dd, mm, yyyy, h, m)
        ),
        |(dd, mm, yyyy, h, m)| {
            NaiveDate::from_ymd_opt(yyyy as i32, mm as u32, dd as u32)
                .and_then(|nd| nd.and_hms_opt(h as u32, m as u32, 0))
                .map(|dt| HeaderClause::Date(dt))
        }
    )
);

named!(subsetdef<&str, HeaderClause>,
    do_parse!(
                tag!("subsetdef:")  >>
                many1!(ws)          >>
        i:      id                  >>
                many1!(ws)          >>
        desc:   quoted_unescape     >>
                (HeaderClause::Subsetdef(i, desc.to_string()))
    )
);

named!(synonymtypedef<&str, HeaderClause>,
    do_parse!(
                tag!("synonymtypedef:") >>
                many1!(ws)              >>
        i:      id                      >>
                many1!(ws)              >>
        desc:   quoted_unescape         >>
                many0!(ws)              >>
        scope:  opt!(synonym_scope)     >>
                (SynonymTypedef(i, desc, scope))
    )
);

named!(unreserved<&str, HeaderClause>,
    do_parse!(
        k:  take_till1!(|c| c == ':' || is_whitespace(c) || is_newline(c)) >>
            tag!(":")                                                     >>
            opt!(ws)                                                      >>
        v:  take_till!(|c| is_newline(c))             >>
            (HeaderClause::Unreserved(k.to_string(), v.to_string()))
    )
);

// --- Final parser ------------------------------------------------------------

/// Parse a header clause into the appropriate [`HeaderClause`] enum value.
pub fn header_clause(i: &str) -> nom::IResult<&str, ast::HeaderClause> {
    #[cfg_attr(rustfmt, rustfmt_skip)]
    alt_complete!(i,
            date
        |   format_version
        |   data_version
        |   saved_by
        |   auto_generated_by
        |   remark
        |   ontology
        |   subsetdef
        |   synonymtypedef

        // NB: MUST REMAIN LAST
        |   unreserved
    )
}

#[cfg(test)]
mod tests {

    use chrono::naive::NaiveDateTime;

    use super::*;

    #[test]
    fn format_version() {
        let r1 = super::header_clause("format-version: 1.2\n").expect("parsing failed");
        assert_eq!(r1.0, "\n");
        assert_eq!(r1.1, HeaderClause::FormatVersion(String::from("1.2")));

        let r2 = super::header_clause("format-version:1.2\n").expect("parsing failed");
        assert_eq!(r1.1, r2.1)
    }

    #[test]
    fn saved_by() {
        use super::HeaderClause::SavedBy;
        let r3 = super::header_clause("saved-by: Gerhard Mayer \n").unwrap();
        assert_eq!(r3.0, "\n");
        assert_eq!(r3.1, SavedBy("Gerhard Mayer".to_string()));
    }

    #[test]
    fn ontology() {
        use super::HeaderClause::Ontology;
        let r3 = super::header_clause("ontology: go\n").unwrap();
        assert_eq!(r3.0, "\n");
        assert_eq!(r3.1, HeaderClause::Ontology("go".to_string()));
    }

    #[test]
    fn date() {
        use super::HeaderClause::Date;
        let dt = NaiveDate::from_ymd(2018, 9, 14).and_hms(23, 2, 0);
        let r = super::header_clause("date: 14:09:2018 23:02\n").unwrap();
        assert_eq!(r.0, "\n");
        assert_eq!(r.1, HeaderClause::Date(dt));
    }

    #[test]
    fn subsetdef() {
        let r = super::header_clause("subsetdef: GO_SLIM \"GO Slim\"\n").unwrap();
        assert_eq!(r.0, "\n");
        assert_eq!(
            r.1,
            HeaderClause::Subsetdef(
                super::ast::Id::Unprefixed("GO_SLIM".to_string()),
                "GO Slim".to_string(),
            )
        );
    }

    #[test]
    fn import() {
        let r = super::header_clause("import: http://purl.obolibrary.org/obo/go.owl\n").unwrap();
        assert_eq!(r.0, "\n");
        assert_eq!(
            r.1,
            HeaderClause::Import("http://purl.obolibrary.org/obo/go.owl".to_string())
        );
    }

    #[test]
    fn synonymtypedef() {
        use super::header_clause;

        let r = header_clause("synonymtypedef: UK_SPELLING \"British spelling\" EXACT\n").unwrap();
        assert_eq!(r.0, "\n");
        assert_eq!(
            r.1,
            HeaderClause::SynonymTypedef(
                super::ast::Id::Unprefixed("UK_SPELLING".to_string()),
                "British spelling".to_string(),
                Some(super::ast::SynonymScope::Exact),
            )
        );

        let r2 = header_clause("synonymtypedef: UK_SPELLING \"British spelling\" \n").unwrap();
        assert_eq!(r2.0, "\n");
        assert_eq!(
            r2.1,
            HeaderClause::SynonymTypedef(
                super::ast::Id::Unprefixed("UK_SPELLING".to_string()),
                "British spelling".to_string(),
                None
            )
        );
    }

    #[test]
    fn id_space() {
        let r = super::header_clause(
            "idspace: GO urn:lsid:bioontology.org:GO: \"gene ontology terms\"\n",
        )
        .unwrap();
        assert_eq!(r.0, "\n");
        assert_eq!(
            r.1,
            HeaderClause::IdSpace(
                "GO".to_string(),
                "urn:lsid:bioontology.org:GO:".to_string(),
                Some("gene ontology terms".to_string()),
            )
        );
    }

    #[test]
    fn default_relationship_id_prefix() {
        let r = super::header_clause("default-relationship-id-prefix: OBO_REL\n").unwrap();
        assert_eq!(r.0, "\n");
        assert_eq!(
            r.1,
            HeaderClause::DefaultRelationshipIdPrefix("OBO_REL".to_string())
        );
    }

    #[test]
    fn id_mapping() {
        let r = super::header_clause("id-mapping: part_of OBO_REL:part_of\n").unwrap();
        assert_eq!(r.0, "\n");
        assert_eq!(
            r.1,
            HeaderClause::IdMapping(
                super::ast::Id::Unprefixed("part_of".to_string()),
                super::ast::Id::Prefixed("OBO_REL".to_string(), "part_of".to_string())
            )
        );
    }

    #[test]
    fn treat_xrefs_as_equivalent() {
        let r = super::header_clause("treat-xrefs-as-equivalent: CL\n").unwrap();
        assert_eq!(r.0, "\n");
        assert_eq!(r.1, HeaderClause::TreatXrefsAsEquivalent("CL".to_string()));
    }

    #[test]
    fn treat_xrefs_as_genus_differentia() {
        let r =
            super::header_clause("treat-xrefs-as-genus-differentia: CL part_of NCBITaxon:7955\n")
                .unwrap();
        assert_eq!(r.0, "\n");
        assert_eq!(
            r.1,
            HeaderClause::TreatXrefsAsGenusDifferentia(
                "CL".to_string(),
                super::ast::Id::Unprefixed("part_of".to_string()).into(),
                super::ast::Id::Prefixed("NCBITaxon".to_string(), "7955".to_string()).into(),
            )
        );
    }

    #[test]
    fn treat_xrefs_as_relationship() {
        let r = super::header_clause("treat-xrefs-as-relationship: MA homologuous_to\n").unwrap();
        assert_eq!(r.0, "\n");
        assert_eq!(
            r.1,
            HeaderClause::TreatXrefsAsRelationship(
                "MA".to_string(),
                super::ast::Id::Unprefixed("homologuous_to".to_string()).into(),
            )
        );
    }

    #[test]
    fn treat_xrefs_as_is_a() {
        let r = super::header_clause("treat-xrefs-as-is_a: CL\n").unwrap();
        assert_eq!(r.0, "\n");
        assert_eq!(r.1, HeaderClause::TreatXrefsAsIsA("CL".to_string()));
    }
}
