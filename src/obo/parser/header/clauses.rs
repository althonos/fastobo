//! Per-clause parsers.

use std::str::FromStr;

use chrono::NaiveDate;

use super::super::spacing::is_newline;
use super::super::spacing::is_whitespace;
use super::super::spacing::nl;
use super::super::spacing::ws;
use super::super::values::unquoted_unescape;

use super::ast;
use super::ast::HeaderClause;
use super::ast::HeaderClause::*;

// Derived Implementations
tvp!(
    format_version,
    "format-version:",
    FormatVersion,
    HeaderClause
);
tvp!(data_version, "data-version:", DataVersion, HeaderClause);
tvp!(saved_by, "saved-by:", SavedBy, HeaderClause);
tvp!(
    auto_generated_by,
    "auto-generated-by:",
    AutoGeneratedBy,
    HeaderClause
);
tvp!(remark, "remark:", Remark, HeaderClause);
tvp!(ontology, "ontology:", Ontology, HeaderClause);

// Date clause.
named!(pub date<&str, HeaderClause>,
        map_opt!(
            do_parse!(
                        tag!("date:")                     >>
                        opt!(ws)                          >>
                dd:     map_res!(take!(2), u32::from_str)  >>
                        tag!(":")                         >>
                mm:     map_res!(take!(2), u32::from_str)  >>
                        tag!(":")                         >>
                yyyy:   map_res!(take!(4), i32::from_str) >>
                        ws                                >>
                h:      map_res!(take!(2), u32::from_str)  >>
                        tag!(":")                         >>
                m:      map_res!(take!(2), u32::from_str)  >>
                        (dd, mm, yyyy, h, m)
            ),
            |(dd, mm, yyyy, h, m)| {
                NaiveDate::from_ymd_opt(yyyy as i32, mm as u32, dd as u32)
                    .and_then(|nd| nd.and_hms_opt(h as u32, m as u32, 0))
                    .map(|dt| HeaderClause::Date(dt))
            }
        )
    );

// Unreserved key/value pair.
named!(pub unreserved<&str, HeaderClause>,
        do_parse!(
            k:  take_till1!(|c| c == ':' || is_whitespace(c) || is_newline(c)) >>
                tag!(":")                                                     >>
                opt!(ws)                                                      >>
            v:  take_till!(|c| is_newline(c))             >>
                (HeaderClause::Unreserved(k.to_string(), v.to_string()))
        )
    );

#[cfg(test)]
mod tests {

    use chrono::naive::NaiveDateTime;

    use super::*;

    #[test]
    fn format_version() {
        let r1 = super::format_version("format-version: 1.2\n").expect("parsing failed");
        assert_eq!(r1.0, "\n");
        assert_eq!(r1.1, HeaderClause::FormatVersion(String::from("1.2")));

        let r2 = super::format_version("format-version:1.2\n").expect("parsing failed");
        assert_eq!(r1.1, r2.1)
    }

    #[test]
    fn date() {
        let r1 = super::date("date: 20:09:2018 09:05\n").expect("parsing failed");
        assert_eq!(r1.0, "\n");
        assert_eq!(
            r1.1,
            HeaderClause::Date(NaiveDateTime::from_timestamp(1537434300, 0))
        )
    }

    #[test]
    fn saved_by() {
        use super::HeaderClause::SavedBy;
        let r3 = super::saved_by("saved-by: Gerhard Mayer \n").unwrap();
        assert_eq!(r3.0, "\n");
        assert_eq!(r3.1, SavedBy("Gerhard Mayer".to_string()));
    }
}
